group templates ;

program(programBody, globalVariables) ::= <<
declare i32 @scanf(i8*, ...)
declare i32 @printf(i8*, ...)

<globalVariables; separator="\n">

<programBody; separator="\n\n">
>>

globalString(name, size, body) ::= <<
<name> = global [<size> x i8] c"<body>\00"
>>

globalStringAccess(dest, name, size) ::= <<
<dest> = getelementptr [<size> x i8], [<size> x i8]* <name>
>>

paramInit(destReg, type, initValue, ptrType) ::= <<
<destReg> = alloca <type>
store <type> <initValue>, <ptrType> <destReg>
>>

functionDef(returnType, name, argumentList, code, paramInit, voidFunction) ::= <<
define <returnType> @<name>(<argumentList>)
{
init:
	<paramInit; separator="\n">
	<code>
<if(voidFunction)>
    ret void
<endif>
}
>>

dereference(destType, destReg, ptrType, ptr) ::= <<
<destReg> = load <destType>, <ptrType> <ptr>
>>

writeExpression(valueType, value, ptrType, ptr, expressionCode) ::= <<
<expressionCode>
store <valueType> <value>, <ptrType> <ptr>
>>

arrayIndexing(tmpReg, destReg, ptrReg, destType, ptrType, indexType, indexReg, expressionCode) ::= <<
<expressionCode>
<tmpReg> = getelementptr <destType>, <ptrType> <ptrReg>, <indexType> <indexReg>
<destReg> = load <destType>, <ptrType> <tmpReg>
>>

arrayMultiLevelIndexing(indexing) ::= <<
<indexing; separator="\n">
>>

arrayWrite(tmpReg, valueType, value, ptrType, ptr, indexType, index, previousCode, expressionCode) ::= <<
<expressionCode>
<previousCode; separator="\n">
<tmpReg> = getelementptr <valueType>, <ptrType> <ptr>, <indexType>, <index>
store <valueType> <value>, <ptrType> <tmpReg>
>>

codeBlock(lines) ::= <<
<lines; separator="\n">
>>

argList(arg) ::= <<
<arg; separator=", ">
>>

functionCall(destReg, returnValue, returnType, id, argList, computeParameters) ::= <<
<computeParameters>
<if(returnValue)><destReg> = call <returnType> <id>(<argList>)
<else>call <returnType> <id>(<argList>)
<endif>
>>

/* same signature begin */
zeroExtend(destReg, srcType, value, destType) ::= <<
<destReg> = zext <srcType> <value> to <destType>
>>

signExtend(destReg, srcType, value, destType) ::= <<
<destReg> = sext <srcType> <value> to <destType>
>>

truncate(destReg, srcType, value, destType) ::= <<
<destReg> = trunc <srcType> <value> to <destType>
>>
/* same signature end */

logicalNot(destReg, type, value, valueCode) ::= <<
<valueCode>
<destReg> = icmp eq <type> 0, <value>
>>

/* same signature begin */
subtract(destReg, type, value1, value2) ::= <<
<destReg> = sub <type> <value1>, <value2>
>>

multiplication(destReg, type, value1, value2) ::= <<
<destReg> = mul <type> <value1>, <value2>
>>

addition(destReg, type, value1, value2) ::= <<
<destReg> = add <type> <value1>, <value2>
>>

signedModulo(destReg, type, value1, value2) ::= <<
<destReg> = srem <type> <value1>, <value2>
>>

unsignedModulo(destReg, type, value1, value2) ::= <<
<destReg> = urem <type> <value1>, <value2>
>>

cmpEQ(destReg, type, value1, value2) ::= <<
<destReg> = icmp eq <type> <value1>, <value2>
>>

cmpNE(destReg, type, value1, value2) ::= <<
<destReg> = icmp ne <type> <value1>, <value2>
>>

cmpUGT(destReg, type, value1, value2) ::= <<
<destReg> = icmp ugt <type> <value1>, <value2>
>>

cmpUGE(destReg, type, value1, value2) ::= <<
<destReg> = icmp uge <type> <value1>, <value2>
>>

cmpULT(destReg, type, value1, value2) ::= <<
<destReg> = icmp ult <type> <value1>, <value2>
>>

cmpULE(destReg, type, value1, value2) ::= <<
<destReg> = icmp ule <type> <value1>, <value2>
>>

cmpSGT(destReg, type, value1, value2) ::= <<
<destReg> = icmp sgt <type> <value1>, <value2>
>>

cmpSGE(destReg, type, value1, value2) ::= <<
<destReg> = icmp sge <type> <value1>, <value2>
>>

cmpSLT(destReg, type, value1, value2) ::= <<
<destReg> = icmp slt <type> <value1>, <value2>
>>

cmpSLE(destReg, type, value1, value2) ::= <<
<destReg> = icmp sle <type> <value1>, <value2>
>>
/* same signature end */

/* same signature begin */
logicalAnd(destReg, type, value1, value2, tmp1, tmp2, tmp3, expressionCode1, expressionCode2) ::= <<
<expressionCode1>
<expressionCode2>
<tmp1> = icmp ne <type> 0, <value1>
<tmp2> = icmp ne <type> 0, <value2>
<tmp3> = and i1 <tmp1>, <tmp2>
<destReg> = zext i1 <tmp3> to <type>
>>

logicalOr(destReg, type, value1, value2, tmp1, tmp2, tmp3, expressionCode1, expressionCode2) ::= <<
<expressionCode1>
<expressionCode2>
<tmp1> = icmp ne <type> 0, <value1>
<tmp2> = icmp ne <type> 0, <value2>
<tmp3> = or i1 <tmp2>, <tmp4>
<destReg> = zext i1 <tmp3> to <type>
>>
/* same signature end */

declarationBlock(code) ::= <<
<code; separator="\n">
>>

simpleVarDeclaration(reg, type, init, value, ptrType, expressionCode) ::= <<
<if(init)><expressionCode>
<endif>
<reg> = alloca <type>
<if(init)>store <type> <value>, <ptrType> <reg>
<endif>
>>

codeFragment(code, jump, label) ::= <<
<code>
<if(jump)>br label <label>:
<endif>
>>

concatCodeBlock(code, addFirstLabel, firstLabel) ::= <<
<if(addFirstLabel)><firstLabel>:
<endif>
<code; separator="\n">
>>

while(labelBegin, expressionCode) ::= <<
loop_begin_<labelBegin>:
    <expressionCode>
    <tmpReg> = icmp ne <expressionType> <expressionReg>, 0
    br i1 <tmpReg>, label
>>
