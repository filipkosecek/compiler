group templates ;

program(programBody, globalVariables) ::= <<
    declare i32 @scanf(i8*, ...)
	declare i32 @printf(i8*, ...)
	<globalVariables; separator="\n">
	<programBody>
>>

globalVarDecl(name, llvmType, llvmLiteral) ::= <<
	@<name> = global <llvmType> <llvmLiteral>
>>

globalString(name, size, body) ::= <<
    <name> = global [<size> x i8] c"<body>\00"
>>

globalStringAccess(dest, name, size) ::= <<
    <dest> = getelementptr [<size> x i8], [<size> x i8]* <name>
>>

functionDef(returnType, name, argumentList, code) ::= <<
	define <returnType> @<name>(<argumentList>)
	{
	<code>
	}

>>

store(valueType, valueReg, ptrType, ptrReg, previousCode) ::= <<
    <previousCode>
    store <valueType> <valueReg>, <ptrType> <ptrReg>

>>

add(destReg, type, val1, val2, previousCode) ::= <<
    <previousCode>
    <destReg> = add <type> <val1>, <val2>

>>

dereference(destReg, destType, ptrReg, ptrType) ::= <<
    <destReg> = load <destType>, <ptrType> <ptrReg>

>>

arrayIndexing(tmpReg, destReg, ptrReg, destType, ptrType, indexType, indexReg, previousCode) ::= <<
    <previousCode>
    <tmpReg> = getelementptr <destType>, <ptrType> <ptrReg>, <indexType> <indexReg>
    <destReg> = load <destType>, <ptrType> <tmpReg>

>>

arrayMultiLevelIndexing(indexing) ::= <<
    <indexing; separator="\n">
>>

arrayWrite(tmpReg, valueType, value, ptrType, ptr, indexType, index, previousCode) ::= <<
    <previousCode; separator="\n">
    <tmpReg> = getelementptr <valueType>, <ptrType> <ptr>, <indexType>, <index>
    store <valueType> <value>, <ptrType> <tmpReg>
>>

codeBlock(lines) ::= <<
    <lines; separator="\n">
>>
